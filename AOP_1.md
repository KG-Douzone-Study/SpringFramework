
# AOP (Aspect Oriented Programming) -  1 (XML 기반 설정)

```txt
어플리케이션은 다양한 공통 기능을 필요로 한다.
로깅과 같은 기본적인 기능에서부터 트랜잭션이나 보안과 같은 기능에 이르기까지
어플리케이션 전반에 걸쳐 적용되는 공통기능이 존재한다.

이런 공통기능들은 어플리케이션의 핵심 비지니스 로직과는 구분되는 기능이다.

핵심 비지니스 로직과 구분하기 위해 공통 기능을 공통 관심 사항(Cross-Cutting Concern)이라고
표현하며, 핵심 로직을 핵심 관심 사항(Core Concern)이라고 표현한다.
```

```txt
비지니스 컴포넌트 개발에서 가장 중요한 두 가지 원칙은 낮은 결합도와 높은 응집도를 유지하는 것이다.
```

```txt
스프링의 IoC가 결합도와 관련된 기능이라면 AOP는 응집도와 관련된 기능이라고 할 수 있다.
```

## AOP 용어의 개요

```txt
- Advice : 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의한다.
  예를 들어 언제 ("메서드를 호출하기 전"), 공통기능 ("트랜잭션")을 적용한다는 것을 정의하고 있다.

- JoinPoint : Advice를 적용 가능한 지점을 의미한다.
  메서드 호출, 필드 값 변경 등이 이에 해당한다.

- Pointcut : Joinpoint의 부분 집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타낸다.

- Weaving : Advice를 핵심 로직 코드에 적용하는 것을 weaving이라고 한다.
  즉, 공통 핵심 코드를 핵심 로직 코드에 삽입하는 것이 weaving이다.

- Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 Aspect라고 한다.
  트랜잭션이나 보안, 로깅 등이 Aspect의 좋은 예이다.
```

## Weaving 방식

```txt
A. 컴파일 시에 Weaving 하기
- AspectJ 에서 사용하는 방식.
- 핵심 로직을 구현한 자바 소스 코드를 컴파일 할 때에 알맞은 위치에 공통 코드를 삽입.
- 컴파일 방식을 제공하는 AOP 도구는 공통 코드를 알맞은 위치에 삽입할 수 있도록 도와주는 컴파일러나
  IDE를 함께 제공

B. 클래스 로딩 시에 Weaving 하기
- AOP 라이브러리는 JVM이 클래스를 로딩 할 때 클래스 정보를 변경할 수 있는 에이전트를 제공.
- 에이전트는 로딩한 클래스의 바이너리 정보를 변경하여 알맞은 위치에 공통 코드를 삽입한 새로운 클래스
  바이너리 코드를 사용
- 원본 클래스 파일은 변경하지 않고 클래스를 로딩 할 때에 JVM이 변경된 바이트 코드를 사용하도록 함으로써
  AOP를 적용
- AspectJ 5 버전이 컴파일 방식과 더불어 클래스 로딩 방식을 함께 지원.

C. 런타임 시에 Weaving 하기
- 소스 코드나 클래스 정보 자체를 변경하지 않음.
- 프록시를 이용하여 AOP를 적용.
- 핵심 로직을 구현한 객체에 직접 접근하는 것이 아니라 중간에 프록시를 생성하여 프록시를 통해서
  핵심 로직을 구현한 객체에 접근.
```

---

# Spring 에서의 AOP

- 스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있다.
- 스프링 AOP의 또 다른 특징은 자바 기반이라는 점이다.
- 스프링은 세가지 방식으로 AOP를 구현할 수 있도록 하고 있다.
	- XML 스키마 기반의 POJO 클래스를 이용한 AOP 구현
	- AspectJ 5/6에서 정의한  @Aspect 어노테이션 기반의 AOP 구현
	- 스프링 API를 이용한 AOP 구현
- 위의 어떤 방식을 사용하더라도 내부적으로는 프록시를 이용하여 AOP가 구현되므로 메서드 호출에
  대해서만 AOP를 적용할 수 있다.

## 프록시를 이용한 AOP 구현

스프링은 Aspect 의 적용 대상이 되는 객체에 대한 프록시를 만들어 제공하고 있으며 대상 객체를 사용하는
코드는 대상 객체에 직접 접근하기 보다는 프록시를 통해서 간접적으로 접근하게 된다.

어떤 대상 객체에 대해 AOP를 적용할 지의 여부는 설정파일을 통해서 지정할 수 있으며 스프링은 설정 정보를
이용하여 런타임 시에 대상 객체에 대한 프록시 객체를 생성하게 된다.

대상 객체가 인터페이스를 구현하고 있다면 스프링은 자바 리플렉션 API가 제공하는
java.lang.reflect.Proxy 를 이용하여 프록시 객체를 생성한다.

**인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의되어 있지 않은 메서드에 대해서는
AOP가 적용되지 않는다.**

---

AOP 라이브러리 추가 : mvnrepository.com 에서 aspectjweaver 를 검색해서 pom.xml에 추가

![스크린샷 2023-06-09 오전 11 25 03](https://github.com/ParkRio/ParkRio/assets/96435200/1fe99e79-1ccd-4458-8b28-665a85a1edc3)

스프링 설정파일 수정 : servlet-context.xml 네임스페이스에 AOP 추가

![스크린샷 2023-06-09 오전 11 27 37](https://github.com/ParkRio/ParkRio/assets/96435200/e5bf8853-f6c1-473d-82e7-61ff0f78d189)

```txt
AOP 설정을 root-context 와 servlet-context에 했을 때의 차이점

1. Context 란?
   지금 다루고 있는 웹환경에서의 컨텍스트란, 웹환경상에서의 웹호출처리를 위한 환경설정에 관한 
   각종 정보들을 갖고있는 것이다.

2. root-context.xml vs servlet-context
   Root-context.xml 파일들은 Tomcat 실행시에 로드되며,
   servlet-context.xml 은 클라이언트 요청시 dispatcher Servlet 객체 생성시에 로드된다.
   
   Root Application Context
   - 전체 계층구조에서 최상단에 위치한 컨텍스트
   - 서로 다른 서블릿 컨텍스르에서 공유해야하는 Bean들을 등록해놓고 사용할 수 있다.
   - 웹 어플리케이션 전체에 적용가능한 DB 연결, 로깅기능등에 이용
   - Servlet Context에 등록된 Bean 이용 불가능하다.
   - Serlvet Context와 동일한 Bean이 있을 경우 Servlet Context Bean이 우선시 된다.
   - 하나의 컨텍스트에 정의된 AOP 설정은 다른 컨텍스트의 빈에는 영향을 미치지 않는다.

   Servlet Context
   - 서블릿에서만 이용되는 컨텍스트
   - 타 서블릿과 공유하기 위한 Bean들은 루트 웹 어플리케이션 컨텍스트에 등록해놓고 사용해야 한다.
   - Dispatcher Servlet 은 자신만의 컨텍스트를 생성, 초기화하고
     동시에 root-context를 찾아서 자신의 부모 컨텍스트로 사용
```

```txt
일단 결론!

root-context 와 servlet-context에 계층이 존재함.

AOP 등의 transaction 은 bean 설정을 통해 pointcut (여러 메소드 중 실제 Adivce가 적용될 대상 
메소드)이 결정되는데 root-context 와 serlvet-context 두 군데 bean이 등록되어 있다면 transaction을 처리하지 못하는 경우가 종종 발생한다.

따라서 Adivce를 정의한 aop 패키지를 root-context에서 scan해야 하고, URL 관련 설정을 담고 있는
클래스는 servlet-context에서 scan 해야 한다. (controller, intercepter)
```

```xml
<!-- root-context.xml -->
```

![스크린샷 2023-06-09 오후 2 16 59](https://github.com/ParkRio/ParkRio/assets/96435200/caaf25a8-663e-4363-8da8-7abea7348089)

![스크린샷 2023-06-09 오후 2 20 02](https://github.com/ParkRio/ParkRio/assets/96435200/9172a746-f904-467b-9780-18665a28664a)


---

## AOP 용어와 기본설정

1. **JoinPoint**
   JoinPoint는 클라이언트가 호출하는 모든 비지니스 메소드로 포인트컷의 대상 또는 포인트컷 후보라고도
   하는데 이는 조인포인트 중에서 포인트컷이 선택되기 때문이다.

2. **Pointcut**
   클라이언트가 호출하는 모든 메서드가 조인포인트라면 포인트컷은 필터링된 조인포인트를 의미한다.
   수많은 비지니스 메서드 중에서 우리가 원하는 특정 메서드에서만 횡단관심에 해당하는 공통 기능을
   수행시키기 위해서 Poincut 이 필요하다.

**Pointcut 실습** : root-context.xml 설정
Pointcut은 <aop:pointcut> 엘리먼트로 선언하며 id 속성으로 Pointcut을 식별하기 위한 유일한
문자열을 선언한다.

![스크린샷 2023-06-09 오후 2 31 09](https://github.com/ParkRio/ParkRio/assets/96435200/be5c9ba7-fd90-4c46-918a-8f69de79c68c)

![스크린샷 2023-06-09 오후 2 32 29](https://github.com/ParkRio/ParkRio/assets/96435200/723b3fcc-22c6-4b7f-a397-ffdc7dde6b19)

**결론** : get으로 시작하는 getBoardList() 메서드 호출에만 반응하는 것을 확인할 수 있다.


3. AspectJ의 Pointcut 표현식
- XML 스키마를 이용해서 Aspect를 설정하든 @Aspect 어노테이션을 이용해서 설정하든지
  AspectJ 문법을 이용하여 Pointcut 을 설정한다.
- AspectJ에서는 다양한 Pointcut 명시자를 제공하는데 스프링에서는 메서드 호출과 관련된
  명시자만을 지원하고 있다.

```txt
A. execution 명시자 !!제일 강력함!!
- execution 명시자는 Advice를 적용할 메서드를 명시할 때 사용한다.
- execution(리턴타입패턴 패키지경로패턴.클래스이름패턴.메서드이름패턴(파라미터패턴))
- 각 패턴은 "*" 을 이용하여 모든 값을 표현할 수 있다.
- "." 을 이용해서 0개 이상이라는 의미를 표현할 수 있다.
- 클래스 이름 뒤에 + 를 사용하여 해당 클래스로부터 파생된 모든 자식클래스를 선택.
- 인터페이스 이름 뒤에 + 를 사용하면 해당 인터페이스를 구현한 모든 클래스 선택.

B. within 명시자
- 메서드가 아닌 특정 타입에 속하는 메서드를 Pointcut 으로 설정할 때 사용한다.
- within(com.rio.base..*)
  com.rio.base 패키지 및 그 하위 패키지에 있는 모든 메서드 호출

C. bean 명시자
- 스프링 빈이름을 이용하여 Pointcut을 정의한다.
- bean(sampleService) : 이름이 sampleService인 빈의 메소드 호출

D. Pointcut의 조합
- 각각의 표현식은 "&&" 나 "||" 연산자를 이용하여 연결할 수 있다.
- 스프링 설정 파일에서 "&&" 나 "||" 대신 "and" 와 "or"를 사용하도록 하고 있다.
```


4. Advice
- Advice는 횡단관심에 해당하는 공통기능의 코드를 의미하며 독립된 클래스와 메서드로 작성된다.
  스프링에서는 어드바이스의 동작시점을 "before", "after", "after-returning", "after-throwing", "around" 등 다섯 가지로 지정할 수 있다.


5. Weaving
- 위빙은 포인트컷으로 지정한 핵심관심 메서드가 호출될 때 어드바이스에 해당하는 횡단관심 메서드가
  삽입되는 과정을 의미한다.
- 위빙을 처리하는 방식은 크게 컴파일타임 위빙, 로딩타임위빙, 런타임 위빙이 있지만 스프링에서는
  런타임 위빙 방식만 지원한다.

6. Aspect or Advisor
- Aspect 는 포인트컷과 어드바이스의 결합으로서 어떤 포인트컷 메서드에 대해서
  어떤 어드바이스 메서드를 실행할지 결정한다.

7. AOP 엘리먼트
```txt
1. <aop:config> 엘리먼트
   AOP 설정에서 <aop:config>는 루트 엘리먼트이다.
   스프링 설정파일 내에 여러 번 사용될 수 있으며 하위에 <aop:pointcut>, <aop:aspect>
   엘리먼트가 위치할 수 있다.

2. <aop:pointcut> 엘리먼트
   <aop:pointcut> 엘리먼트는 포인트컷을 지정하기 위해 사용하며 <aop:config>나 <aop:aspect>의
   자식 엘리먼트로 사용될 수 있다.
   <aop:pointcut>은 여러 개 정의할 수 있으며 유일한 아이디를 할당하여 Aspect를 설정할 때
   포인트컷을 참조하는 용도로 사용한다.

3. <aop:aspect> 엘리먼트
   Aspect는 <aop:aspect> 엘리먼트로 설정하며 핵심관심에 해당하는 포인트컷 메서드와 횡단관심에
   해당하는 어드바이스 메서드를 결합하기 위해 사용한다.

4. <aop:advisor> 엘리먼트
   <aop:advisor> 엘리먼트는 포인트컷과 어드바이스를 결합한다는 의미에서 애스팩트와 같은 기능을
   한다. 하지만 트랜잭션 설정 같은 몇몇 특수한 경우에는 Aspect가 아닌 Advisor를 사용해야 한다.
   AOP 설정에서 애스팩트를 사용하려면 어드바이스의 아이디와 메서드 이름을 알아야 한다.
   그런데 어드바이스 객체의 아이디를 모르거나 메서드 이름을 확인할 수 없을 때는 Aspect를 설정할 수
   없다.
```


---

## Advice 동작 시점

| 종 류                  | 설 명                                                                                                         |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- |
| Before Advice          | 대상 객체의 메서드 호출 전에 공통 기능을 실행한다.                                                            |
| After Returning Advice | 대상 객체의 메서드가 예외 없이 실행한 이후에 공통기능을 실행한다.                                             |
| After Throwing Advice  | 대상 객체의 메서드를 실행하는 도중 예외가 발생한 경우에 공통기능을 실행한다.                                  |
| After Advice           | 대상 객체의 메서드를 실행하는 도중에 예외가 발생했는지의 여부과 상관없이 메서드 실행 후 공통 기능을 수행한다. |
| Around Advice          | 대상 객체의 메서드 실행 전 후 또는 예외 발생 시점에 공통 기능을 실행하는데 사용된다.                          |
|                        |                                                                                                               |
|                        |                                                                                                               |


